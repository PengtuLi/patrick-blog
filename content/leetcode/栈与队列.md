## 理论基础

:::info[TLDR]

- 栈：先进后出
- 队列：先进先出

:::

`C++`：栈和队列属于STL，但往往将其认为是container adapter，因为其底层实现可以
是vector，list，deque, etc.

`python`

- python里list与栈类似
- deque可以模拟队列也可以模拟栈
- queue.Queue不可以获取队头元素且不弹出，不推荐

均不提供迭代器进行迭代

## [LC232-用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

:::info[TLDR]

用栈实现队列的操作，如push, pop, peek, empty, etc.

:::

解法：

- 双栈模拟队列，很简单，$O(n)$ 复杂度，需要注意的是
  - 何时进行input->output的迁移
  - output为空时的处理

## [LC225-用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

:::info[TLDR]

队列实现栈的操作，如push, pop, top, empty
类似`LC225`
:::

解法：

- 双队列模拟栈
  - 插入时队尾插入，弹出时需要弹出队尾的元素，因此弹出$n-1$个元素，最后一个就是要输出的
  - 复杂度插入$O(1)$，弹出$O(n)$,平均复杂度$O(n^2)$
- 单队列
  - 复杂度，插入$O(n)$,平均复杂度$O(n^2)$
  - 关键是让每次插入后队头都是栈头元素，因此关键就是push的时候先插入元素，再把里面的元素都弹出来再插入

## [LC20-括号匹配](https://leetcode.cn/problems/valid-parentheses/)

:::info[TLDR]

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

一个有效的例子：`{[]}{}()`

:::

解法：用栈做匹配，基本的思路就是是左边的符号就推入栈，遇到右边的符号是就弹出栈进行匹配。
关键是确定何时匹配不上,`$`代表匹配成功的部分

- `[$`or`$[`左边符号多了，对应的是栈不为空
- `]$`or`$]`，同理，需要匹配时栈为空
- 不匹配

<details>

<summary>python</summary>

```python showLineNumbers
from collections import deque

def advers_char(c):
    d={
        '}':'{',
        ']':'[',
        ')':'('
    }
    return d[c]

class Solution:
    def isValid(self, s: str) -> bool:
        l = deque()
        for c in s:
            if c == '}' or c == ']' or c == ')':
                advers=advers_char(c)
                # case 1: right
                if len(l)==0:
                    return False
                top=l.pop()
                if top==advers:
                    continue
                else:
                    # case 3: not match
                    return False
            l.append(c)
        # case 2: left
        if len(l)!=0:
            return False
        return True
```

</details>
